<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>无标题文档</title>
	<script>
//		<p>This is a <i>simple</i> docuemnt.</p>
//		
//		观察上面的代码，并问自己一个问题，<p>元素的“内容”是什么？回答这个问题也许有三个方法：
//		1.内容是HTML字符串"this is a <p>simple</p> document";
//		2.内容是纯文本字符串"this is a simple document";
//		3.内容是一个Text节点，一个包含了一个Text子节点的Element节点和另外一个Text节点。
//		
//		以上三种说法都是有效的。
//		
//		作为HTML的元素内容：
//		
//		读取Element的innerHTML属性作为字符串标记返回的那个元素的内容。在元素上设置该内容调用了Web浏览器的解析器，用新字符串的解析内容替换元素、
//	当前内容，不止在HTML上，XML上也可以使用innerHTML属性。一般来说，用innerHTML效率非常高，但是用于"+="的时候，会追加一小串文本会变得效率低下。
//	
//		HTML5还标准化了outerHTML属性，当查询outerHTML属性时，返回的HTML或XML标记的字符串包含被查询内容的开始和结束标签，当设置outerHTML属性
//	时，元素本身被新的内容所替换，只有Element节点定义了outerHTML属性，Docuemnt节点则无。
//		此外，HTML5还引入了另一个方法，insertAdjacentHTML()方法，它将任意的HTML标记字符串插入到指定的元素"相邻"的位置，标记是该方法的第二个
//	参数，"相邻"的精确含义则依赖于第一个参数，第一个参数的值为以下四个字符串之一:"beforebegin" "afterbegin" "beforeend" "afterend"，
//	这些值对应的插入点如下所示：
//		("beforebegin")<div id="target">(afterbegin)this is the element content(beforeend)<div>(aferend);
//		
//		有时需要查询纯文本形式的元素内容，或者在文档中插入纯文本，标准的方法是使用Node的textContent属性来实现：
//		{
//			var para = docuemnt.getElementsByTagName("p")[0]; //文档中的第一个<p>
//			var text = para.textContent;
//			para.textContent = "hello world!";
//		}
//		textContent属性在除了IE的所有当前的浏览器都支持，在IE中可以用Element的innerText属性来代替，而innerText和textContent通常可以
//	相互替代：
//		{
//			//一个参数，返回元素的textContent或innerText值，两个参数，用value来设置元素的textContent或innerText
//			function textContent(element, value) {
//				var content = element.textContent;
//				if (value === undefined) {
//					if(content !== undefined) return content;
//					else return element.innerText;
//				}else{
//					if (content !== undefined) element.textContent = value;
//					else element.innerText = value;
//				}
//			}
//		}
//		textContent属性就是简单的将指定元素的所有后代Text节点串联到一起。而innerText没有一个明确指点的行为，但是和textContent有一些不同，
//	innerText不返回<script>元素的内容，它忽略多余的空白，并试图保留表格格式，同事，innerText针对某些表格元素只读的属性。
//	
//		另一种方法处理元素的内容是当作一个子节点列表，每一个子节点可能有它的一组子节点，当考虑元素内容的时候，感兴趣的可能是它的文本内容，即
//	Text节点，在XML文档中，你必须做好处理CDATASection节点————它是Text的子类型，代表了CDATA段的内容。
//		下面是一个textContent()方法，它递归的遍历元素的子节点，然后连接子节点中的的所有Text节点的文本内容。
//		
//		{
//			function textContent(e) {
//				var child, type, result = "";
//				for(child = e.firstChild; child != null; child = child.nextSibling) {
//					type = child.nodeType;
//					if(type === 3 || type === 4)
//						s += child.nodeValue;
//					else if(type === 1) 
//						s += textContent(child);
//				}
//				return result;
//			}	
//		}
//		其中的nodeValue属性可以读/写，设置它可以改变Text或CDATASection节点所显示的内容。Text和CDATASection都是CharacterData的子类型
//	，CharaterData定义了data属性，他的内容和nodeValue一样，下面的函数，可以把Text节点的内容转换成大写。
//		
//	{
//		//递归的把n的后代子节点中的Text节点内容转换成大写
//		function upcase(n) {
//			if(n.nodeType === 3 || n.nodeType === 4)
//				n.data = n.data.toUpperCase();
//			else{
//				for(var i = 0; i < n.childNodes.length; i++)
//					upcase(n.childNodes[i]);
//			}
//		}
//	}
//		CharaterData还定义了一些在Text和CDATASection节点中不太常用的的方法来添加，删除，插入和替换文本。除了修改已存在的Text节点的内容，
//	还可以在Element对象中插入全新的Text或用新的Text节点来替换已有节点。
//	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	</script>
</head>

<body>
</body>
</html>
