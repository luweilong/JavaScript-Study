<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>无标题文档</title>
	<script>
//		对客户端程序员来说，最重要的CSS属性是那些指定文档中每个元素的尺寸，可见性和位置的属性，其他的CSS属性允许指定堆叠次序，透明度，裁剪区域，外
//	边距，内边距，边框和颜色。下面有一些重要的CSS样式属性：
//	
//		属性				描述
//		position		 指定元素的定位类型
//		top、left		指定元素上、左边缘的位置
//		bottom、right	指定元素下，右边缘的位置
//		width、height	指定元素的尺寸
//		z-index			指定元素相对于其他重叠元素的“堆叠次序”，定义了元素定位的第三个维度
//		display			指定元素是否以及怎么显示
//		visibility		指定元素是否可见
//		clip			指定元素的“裁剪区域”，只显示元素在区域内的部分
//		overflow		指定元素的内容比指定区域大时的处理方式
//		margin、
//		padding、
//		border			指定元素的空白和边框
//		background		指定元素的背景颜色和图片
//		opacity			指定元素的不透明度
//		
//		
//		接下来挨个讲述CSS属性的详细内容：
//		
//		1.position：指定了应用到元素上的定位类型：
//		static: 默认属性，指定元素按照常规的文档内容流进行定位，静态定位的元素不能示使用top、left和类似其他的属性定位，就对文档元素定位，必先将
//	其position属性设置为其余的值才行。
//		absolute：该值是相对于包含他的元素进行定位，相对于其他所有元素，绝对定位的元素是独立的，它不是静态文档内容流的一部分，它的定位要么是相对
//	于最近的定位的祖先元素，要么是相对于文档本身。
//		fixed：该值指定元素是相对于浏览器窗口定位的，固定定位的元素总是显示在那，不会随文档的其他部分的滚动而滚动，类似于绝对定位的元素，固定定位
//	的元素也是相对于其他部分独立的，他不是文档流的一部分。
//		relative：当position取值为relative时，它会按照常规的文档内容流排布，但是会相对于其本身在文档流中的位置而调整，系统会保留着元素在正常
//	文档流中的空间，不会因为要填充空间而将各边合拢，也不会将元素从新的位置推开。
//	
//		一旦设置的元素的position为static的其他取值时，就可以使用top、left、bottom、right来指定元素的位置，一般来说使用top和left两个属性就
//	足够了，有必要时，也可以使用bottom和right来定位。
//	
//		2.除了定位元素外，通常还需指定元素的尺寸，可以使用width和height属性来完成，另外一种指定元素尺寸的方法是，同时指定元素的left和right，同样
//	通过同时指定元素的bottom和top属性可以指定元素的高度。但是注意，如果同时指定了left、right、width，那么width会覆盖right属性。同理。height
//	会覆盖bottom属性。
//	
//		当然，CSS指定位置和尺寸的时候是带有单位的，我们可以使用px像素，pt点，cm厘米，in英寸和em字体行高。
//		
//		3.第三个维度：z-index，left、right、top、bottom是指定了元素的X坐标和Y坐标，而z-index是指定了元素的第三个维度，他允许指定元素的堆叠
//	次序，指示两个或多个重叠元素的哪一个应该绘制在哪一个上面。z-index默认为0，可以是正的或负的整数，当两个或多个元素重叠在一起的时候，他们是按照
//	从低到高的顺序绘制的，如果重叠元素的z-index一样，那么将按照元素在文档中出现的顺序来绘制，也就是说，最后一个重叠的元素会绘制在最上面。
//	
//		需要注意的是，z-index属性值对兄弟元素起作用，如果两个元素不是兄弟元素，那么设置他们的z-index属性无法决定哪一个显示在最上面，相反，必须
//	设置这两个兄弟元素的容器的z-index来达到目的。
//		在非定位元素中总是以防止元素重叠的方法来进行布局，因此z-index属性不会应用到他们上面，尽管如此，他们有一个默认的z-index的值为0，这意味着
//	z-index为正的元素会显示在文档流的上面，而负的z-index元素会显示在文档流的下面。
//	
//		4.CSS允许指定元素的边框，内边距，外边距，元素的边框是一个围绕着元素的矩形。边框属性还可以指定边框的颜色、厚度和样式：
//			border: solid red 3px; /*绘制一个3px的红色的实线边框*/
//		除了使用符合属性，你也可以单独的设置边框的样式，例如要绘制元素下面的一条边框，使用border-bottom即可，甚至可以单独的指定边框的颜色和样式：
//	如border-bottom-color，border-bottom-style。
//		而margin和padding属性主要用来指定元素周围的空白，主要的区别是，margin指定的是边框外面，即边框和周边元素的之间的空白，而padding指定的是
//	元素的内容和边框之间的空间。可以使用margin： 5px；来指定元素的外边距，也可以单独的设置每个方向的外边距，margin-top，margin-left，也可以直
//	接使用margin同时指定4条边的外边距；
//		margin：1px 2px 3px 4px;它的顺序是上右下左。
//		
//		5.box-sizing，为了理解这个属性，首先要明确一点，标准的width和height属性只指定了元素内容区域的尺寸，它不包含元素的内边距和边框所需的空间
//	即，一个带边框的元素在屏幕上的全尺寸是，元素的宽度加上左右两边的内边距再加上左右两边边框的宽度，同理，元素的高度加上上下内边距和上下边框的宽度。
//	但是在IE6以及IE的怪异模式下，元素的width和heigth属性是包含内边距和边框的，这是一个bug基于这一点，CSS引入了box-sizing属性，默认的取值是
//	content-box，他指定了标准的盒子模型，如果设置为border-box则为IE下的盒子模型，有的时候特别有用。
//	
//		6.display和visibility，这两个元素影响了元素的可见性，visibility很简单，当设置为hidden时，元素不可见，设置为visible时，元素可见，
//	而display更加的通用，它用来为接受他的容器指定元素的显示类型，他指定元素是块级元素，内联元素，列表项等，但是，当display设置为none时，受
//	影响的元素将不会显示，甚至没有布局。这两个属性之间的差异可以从它们对使用静态或相对定位的元素的影响中看到，对于一个常规布局流中的元素，设置
//	visibility的hidden使得元素不可见，但是在文档布局中仍然保留了他的空间，类似的元素可以重复隐藏和显示而不改变文档布局，但是如果元素的display
//	设置成了none，那么，文档布局将不再给它分配空间，它各边的元素会合拢，就当它从不存在。
//		
//		7.CSS可以通过color属性指定文档元素包含的文本的颜色，也可以通过background-color属性指定任何元素的背景颜色，早的时候，我们可以看到
//	border-color属性或border复合属性来指定边框的颜色。而作为颜色，可以使用常见的颜色的英文名，如red，yellow等，但是一般使用的是十六进制数分别
//	指定组成的颜色的红，绿蓝分量，每个分量可以使用一位或者两位数字，例如：#000000是黑色，也可以使用RGBA色彩空间和HSL和HSLA色彩规范，除了IE之外
//	现代浏览器都支持这些色彩。
//		
//		8.背景：除了background-color之外，还有background-image属性，可以为元素指定背景图片，还有一些用于图像的高级细节的属性，如
//	background-attachment，background-position，background-repeat等。也可以使用复合属性background一次性指定这些属性。
//	
//		9.透明度，如果一个元素没有指定任何的背景图片和颜色，那么他的背景通常是透明的，理解这点非常重要，即一个<div>元素绝对定位在一些常规文档流
//	的文本上面，那么文本将会透过<div>显示出来，如果<div>包含自己的文本，那么这些文本将会重叠在一起。尽管如此，并不是所有元素默认情况下都是透明的
//	，很多元素都有自己的默认背景颜色。而且元素要么是全透明的要么就是不透明的，使用opacity来处理，该属性的取值是0-1之间的数字，1代表不透明，0代表
//	透明，opacity除了IE都支持，IE里面使用特有的filter属性。
//		
//		10.部分可见：visibility属性可以让文档元素完全隐藏，而overflow和clip属性允许只显示元素的一部分。overflow属性指定内容超过元素的大小时该
//	如何显示，它的取值有以下几个：
//		visible，默认值，如果需要，内容可以移除并绘制在元素的边框的外面。
//		hedden，裁剪掉和隐藏溢出的内容，即在元素尺寸和定位属性值定义的区域外不会绘制内容。
//		scroll，元素一直显示水平和垂直滚动条，如果内容超过元素尺寸，允许用户通过滚动来查看元素的内容。
//		auto，只有元素的内容超过元素的尺寸时，才会出现滚动条。而非一直显示。
//		
//		overflow属性允许指定当前内容超过元素时如何显示，而clip属性则指定了超过元素尺寸时显示哪些内容，它指定了元素的裁剪区域，裁剪区域一般是矩形
//	的，语法如下，rect(top,right,bottom,left);需要注意的是，括号里面的值是长度，所欲需要单位，而且在书写的时候用空格隔开，不需要使用逗号。
//	
//	
//		脚本化CSS最直接的做法就是改变元素的style属性，类似于大多数HTML属性，style也是元素的属性之一，可以通过JavaScript来操作。但是style属性
//	不同寻常，它的值不是字符串，而是一个CSSStyleDeclaration对象，该style对象的属性代表了HTML可以通过代码改变的HTML的style指定的CSS属性。
//		需要注意的是，在使用CSSStyleDeclaration对象的style属性时，记住所有的值都是字符串，在样式表中可以这样书写：
//		position: absolte; font-family: sans-serif;
//		但是在JavaScript中为e元素完成同样的事情则需要把值放在引号中：
//		e.style.position = "absolute";
//		e.style.fontFamily = "sans-serif";
//		记住，所有的位置定位都要包含单位：
//		e.style.left = 300;
//		e.style.left = "300";
//		以上两种方法都是错误的，首先已经说过，值要看作字符串放在引号里面，其次需要带上单位。
//		
//		脚本化CSS最常见的用途之一就是产生视觉效果，可以使用先前学过的计时器，setTimeout()或setInterval()来重复的修改元素的样式达到效果。现在
//	可以有专门的动画效果来使用，可以使用transition属性来专门的编写一个运动的过程。
//	
//		
		
	
	</script>
</head>

<body>
</body>
</html>
