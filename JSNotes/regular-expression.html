<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>无标题文档</title>
	<script>
		var pattern1 = /s$/; //匹配所有以s结尾的字符串
		
		var pattern2 = new RegExp("s$");//等价于pattern1
		
		//ES3和ES5的不同
		
		function getRE() {
			var re = /[a-z]/;
			re.foo = "bar";
			return re;
		}
		var re1 = getRE(),
			re2 = getRE();
		console.log(re1 === re2); // ES3中返回true，ES5中返回false
		
		re1.foo = "baz";
		
		console.log(re2.foo); //ES3中返回"baz", ES5中返回"bar"
		console.log("------------------------------------");
		
		//正则表达式中的字符直接量
//		字符			   匹配
//		字母和数字字符		自身
//		\o				NUl字符(\u0000)  //???
//		\t              制表符(\u0009)
//		\n				换行符(\u000A)					  
//		\v				垂直制表符(\u000B) 
//		\f				换页符(\u000C)
//		\r  			回车符(\u000D)
//		\xnn			由16进制数指定的拉丁字符  //???
//		\uxxxx 			由16进制数指定的Unicoe字符
//		\cX				控制字符^X //???

//		许多标点符号具有特殊的含义：
//		^ $ . * + ? | \ / ( ) { } [ ]
		
//		---------------------------------------------------------------------
		
//		字符类：将直接量字符单独放进方括号内就组成了字符类
		
//		字符				匹配
//		[...]			方括号里面的任意字符
//		[^...]			不在放括号里面的任意字符
//		.				除了换行符和其他Unicoe行终止符之外的任意字符
//		\w 				任何ASCII字符组成的单词，等价于[a-z0-9A-Z]
//		\W				任何不适ASCII字符组成的单词，等价于[^a-z0-9A-Z]
//		\s				任何Unicode空白符
//		\S				任意非Unicode空白符的字符
//		\d				任何ASCII数字，等价于[0-9]
//		\D				任何非ASCII数字,等级于[^0-9]
//		[\b]			退格直接量[特例]
		
//		--------------------------------------------------------------------

		//我们常常在正则模式之后跟随用以指定字符重复的标记
		
//		字符				含义
//		{n,m}			匹配前一项至少n次，但不能超过m次
//		{n,}			匹配前一项n次或者多次
//		{n}				匹配前一项n次
//		?				匹配前一项0次或者1次，等价于{0,1}
//		+				匹配前一项1次或者多次，等价于{1,}
//		*				匹配前一项0次或者多次，等价于{0,}
		
//		注意:使用"*"和"?"时要谨慎，由于这些字符可能匹配0个字符，因此它们允许什么都不匹配
		
		
//		--------------------------------------------------------------------
		
//		贪婪：以上列出的匹配重复字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，我们称之为”贪婪“
//		我们同样可以使用正则表达式进行非贪婪式匹配，只须在待匹配的字符后跟随一个问号即可:
//		"??" "+?" "*?" "{1，5}?"
		
//		正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符：
//		
//		字符				含义
//		|				 选择，匹配的是该符号左边的子表达式或右边的子表达式
//		
//		(...)			 组合，将几个项组合为单元，这个单元可以通过"*"、"+"、"?"、"|"
//		 				 等符号进行修饰，而且可以记住和这个组合相匹配的字符串供以后的引用使用
//		 
//		(?:...)			 只组合，把项组合到一个单元，但不记忆与该组相匹配的字符
//		
//		\n 				 和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌
//						 套的），组索引是从左到右的括号数，"(?:" 形式的分组不编码

		
//		--------------------------------------------------------------------
		
		
		
//		锚字符：有一些正则表达式的元素匹配的是字符之间的位置，而不是实际的字符
		
//		正则表达式中的锚字符:
//		
//		字符				含义
//		^				 匹配字符串的开头，在多行检索中，匹配一行的开头
//			
//		$				 匹配字符串的结尾，在多行检索中，匹配一行的结尾
//		
//		\b				 匹配一个单词的边界，即位于\w与\W之间的位置，或者位于字符\w和字符串
//						 的开头或者结尾的之间的位置
//		
//		\B				 匹配非单词的边界
//	
//		(?=p)			 零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括p的那些字符
//		
//		(?!p)			 零宽负向先行断言，要求接下来的字符都与p不匹配
		
		
//		--------------------------------------------------------------------
		
//		修饰符：用以说明正则表达式高级匹配规则的说明符
		
//		有三种修饰符：
//		字符				含义
//		i				 执行不区分大小写的匹配
//		g				 执行一个全局匹配，即找到所有的匹配项，而不是找到第一个就停止
//		m				 多行匹配模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾和字符串的结尾
		
//		--------------------------------------------------------------------
		
		
//		用于模式匹配的String方法：
		
//		1、search :用于检索
		
//		参数：正则表达式(若不是正则表达式，则会RegExp构造函数将其转换为正则表达式)；
//		返回值：返回第一个匹配的子串的起始位置，若无匹配，返回-1；
//		注意：search方法不支持全局匹配，会忽视修饰符 g ；
		
		"JavaScript".search(/script/i);			// 返回 4
		
//		2、replace : 用于检索和替换
//		
//		参数：第一个参数可以是正则表达式或字符串（会直接检索该字符串）
//			 第二个参数可以是字符串，也可以是一个函数
//		返回值： ？？？
		
		//将text中的所有不区分大小写的javascript替换成大小写正确的JavaScript
//		text.replace(/javascript/gi, "JavaScript");			
		
//		3、match ： 用于检索匹配
//		
//		参数：正则表达式（或通过RegExp构造函数转化为正则表达式）
//		返回值：由匹配结果组成的一个数组，存在两种情况：
//		a.如果参数里设置了修饰符 g ，则该方法返回的数组包含字符串中所有的匹配结果。
//		例：
			"1 plus 2 equals 3".match(/\d+/g);	//返回["1", "2", "3"]
		
//		b.如果参数没有设置修饰符 g ，match()不会执行全局检索，它只检索第一个匹配。但即使match()不是执行的全局检索，
//		  它也返回一个数组，这种情况下，数组第一个存放的是match()的匹配结果，余下的则是与正则表达式中用圆括号阔起来
//		  的子表达式相匹配的字串。
//		例：
			var url = /(\w+):\/\/([w.]+)\/(\S*)/;
			var text = "Visit my blog at http://www.example.com/~david";
			var result = text.match(url);
			if(result != null) {
				var fullurl = result[0];	//包含 "http://www.example.com/~david"
				var protourl = result[1];	//包含 "http"
				var host = result[2];	//包含 "www.example.com"
				var path = result[3];	//包含 "~david"
			}
		
//		4、split : 把调用它的字符串拆分为一个字串的数组，使用的分隔符是split()的参数
		
//		参数：可以是一个字符串或者正则表达式
//		返回值：返回字串组成的数组
//		例：
		"123,456,789".split(","); //返回["123", "456", "789"]
		
//		RegExp对象：
//		
//		RegExp()构造函数有两个字符串参数，第一个参数包含正则表达式的主体部分，第二个参数是可选的，指定了
//		正则表达式的修饰符，只能是g, i ,m或者它们的组合；
		
//		RegExp的属性：每个RegExp对象都有5个属性，它们分别是：
//		1.source 只读的字符串，包含正则表达式的文本
//		2.global 只读的布尔值，用以描述该正则表达式是否含有修饰g
//		3.ignoreCase 只读的布尔值，用以描述该正则表达式是否含有修饰i
//		4.multiline 只读的布尔值，用以描述该正则表达式是否含有修饰m
//		5.lastIndex 可读/写的整数，若正则表达式带有g修饰符，这个属性储存在整个字符串中下一次检索的开始位置
		
//		RegExp的方法：
//		
//		1、exec():与String的match()方法类似
//		参数：接受一个用于匹配检索的字符串
//		返回值：当没有任何匹配的时候，返回null
//			  若有任何匹配，它将返回一个数字，与match()方法没有进行全局检索返回的数组一样
//		该方法还包含了两个属性：
//				index：发生匹配的字符位置；
//				input：引用的是正在检索的字符串；、
//		例：
//			var pattern = /Java/g;
//			var text = "JavaScript is more fun than Java";
//			var result;
//			while((result = pattern.exec(text)) != null) {
//				alert("Matched " + result[0] + "'" + " at position " + result.index +
//					 "; next search begins at " + pattern.lastIndex);
//			}
		
//		2、test(): 对某个字符串进行检测
//		参数：待检测的字符串
//		返回值：若包含正则表达式第一个匹配结果，返回true
//		例：
//			var pattern = /java/i;s
//			pattern.test("JavaScript") //返回true		
	
	</script>
</head>

<body>
</body>
</html>
